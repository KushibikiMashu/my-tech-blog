---
title: "2"
date: "2022-01-15T18:37:05.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/tdd-2"
category: ""
tags:
    - ""
description: ""
socialImage: "/media/2022/01/15/2022_01_15__0.png"
---

第２章 ローカルでテストをする環境を作る

# テストの一般的な分類
TDD の解説に入る前にテストの分類について解説します。ソフトウェアのテストにはユニットテストや、インテグレーションテスト、E2E テストなどテストの対象・方法に応じた様々な分類があります。それらを簡単に説明した後、テスティングフレームワークである Jest を用いて JavaScript のユニットテストを実行できる環境を構築し、GitHub Actions でテストの実行を自動化します。

## ユニットテスト
ユニットテストは単体テストとも呼ばれます。これはテスト対象を1つの関数や1つのクラスに絞ったテストです。このため、ユニットテストはテストの粒度が小さく、またテスト対象に依存関係がないことからそれぞれ独立しているという性質があります。

なお、本章の後半で掲載しているテストコードはユニットテストなので、先に○ページを見ていただくと分かりやすいでしょう。

## インテグレーションテスト
インテグレーションテストは結合テストとも呼ばれます。これはユニットテストとは異なり、複数の関数やクラスを対象としたテストです。このため、ユニットテストより粒度が大きいです。

また、データベースやネットワークなどからデータを読み書きする処理など、ソフトウェア自身の外側に依存関係を持つ対象のテストもインテグレーションテストです。

## 振る舞いテストやE2Eテストなどその他のテスト
上記2つの他にも様々なテストがあります。いくつか例を挙げると、ソフトウェアの仕様・要求に基づいた形式でテストを記述する振る舞いテスト（Behavioral Test）や、システム全体を統合して期待通りの動きをすることをテストするE2Eテスト（End to End Testing。Web サイトであればテストにブラウザを使います）、コードの変更前と変更後の画面のスクリーンショットを撮影し、前後の画像を比較することで UI の差分を発見するビジュアルリグレッションテスト（Visual Regression Test。フロントエンドで HTML や CSS の差分を確認するために使われます）、ソフトウェアの品質向上を目的として想定外のバグを発見したり、仕様を把握するために行う探索的テスト（Exploratory Testing）などがあります。

なお、ユニットテストではなくソフトウェアの振る舞いや受け入れテストを書くことで開発を駆動する TDD から派生した BDD（Behavior Driven Development）や ATDD（Acceptance Test Driven Development）という技法もあります。

（櫛引コメント: BDD/ATDDは言葉だけでも紹介したいものの、櫛引自身にこの経験が浅く、取ってつけたような書き方になっているところがちょっと気になります...。良い紹介の方法があれば教えていただきたく思います。ただ、最後の一文を削除するのもありかなあと思ってもいます）

# テストに対する考え方
（櫛引コメント: 「テストの種類を紹介する -> 各テスト間の関係を整理する」という流れから、この節を書きました。ただ、和田さんの見出し案にある「設計がボトムアップなものになりがち」という箇所でテストピラミッドとトロフィーのことが含まれているため、この節は削除してしまってもいいかもしれません）

次に、テストピラミッドとテスティングトロフィーという、ユニットテスト・インテグレーションテスト・E2E テストのそれぞれの関係に対する考え方を紹介します。

## テストピラミッド
テストピラミッドは Mike Cohn 氏が考案し、エンジニアの間で幅広く受け入れられている考え方です（図: Test Pyramid。）。

ピラミッドの下のテストほど粒度が小さく実行速度が速いです。ピラミッドの上のテストほど粒度が大きくて実行速度が遅いですが、1つのテストが担う範囲は広くなります。

ピラミッドの幅はテストの数であり、粒度の小さいテストほどたくさん記述し、粒度が大きいものは相対的に記述数が少なくなるということを表しています。（注釈）

（注釈）https://martinfowler.com/articles/practical-test-pyramid.html

## テスティングトロフィー
テスティングトロフィーは Kent C. Dodds 氏が考案したフロントエンドのアプリケーションにおけるテストの考え方であり（図: Testing Trophy）、フロントエンドエンジニアの間で支持されています。

トロフィーの下の方のテストは粒度が小さく実行時間が短いという点はテストピラミッド同じですが、特にインテグレーションテストを多く書くと効率が良いという点と、型の検査や Lint など静的解析をテストの一種として加えている点に特色があります。

https://testingjavascript.com/
https://kentcdodds.com/blog/static-vs-unit-vs-integration-vs-e2e-tests

# ローカルでテストを実行する環境の構築
TDD はテストピラミッドとテスティングトロフィーの下部にあり、素早く実行できるユニットテストを作成することでフィードバックを素早く得て実装を進める手法です。そこで、ユニットテストを実行できる環境をローカルに構築しましょう。（注釈）

（注釈: この章で実装したコードは以下の URL で公開しています。 https://github.com/KushibikiMashu/tdd-js-sample）

## プログラミング言語とテストツールの選定
今回は使用言語に JavaScript（Node.js）を、テスティングフレームワークに Jest を選択します。なお、本記事で Node.js は16.13.2、Jest は27.4.7のバージョンを使用しています。

また、ローカルでの環境構築をスキップしたいのであれば、Web 上でテストが実行できる cyber-dojo（注釈1）を利用しても構いません。（注釈2）

（注釈1）https://cyber-dojo.org/creator/home
（注釈2）ページにアクセスして「create a new practice > skip > JavaScript, jest > solo > ok」の順に進んで行き、「test」をクリックすると Jest でテストが実行されます。

## ローカルでの環境構築
まずは JavaScript のプロジェクトを作成するため、以下のコマンドを実行します。

```
$ npm init -y
```

package.jsonが作成されました。次にJestを導入します。

```
$ npm install --save-dev jest
```

package.json の devDependencies に Jest が追加され、ローカルで Jest が実行可能になりました。

```
"devDependencies": {
  "jest": "^27.4.7"
}
```

## テストを作成する
JavaScript でテストを実行する環境を構築できたので、実際に簡単なテストを記述して Jest が動作することを確認してみましょう。プロジェクト配下に`index.js`と`index.test.js`を作成します。

```
$ touch index.js index.test.js
```

まずは index.js で引数を足し算する関数`add`を作成します。

```
function add(a, b) {
  return a + b;
}

module.exports = add
```

次に、index.test.jsにテストを記述します。

```
const add = require('./index')

test('1と2を渡したとき、3を返す', ()=> {
  expect(add(1, 2)).toBe(3);
});
```

なお、この記事ではテスト名を日本語で記述します。各テストは「〇〇なとき、□□を返す」という状況と結果を表現する書き方を採用します。

## テストを実行する
### package.json にtestコマンドを記述する
次に、package.json の scripts の test を`jest`に書き換えます。

```
"scripts": {
  "test": "jest"
}
```

これで`npm run test`を実行すると Jest を動かすことが可能になります。

### テストコマンドを実行する
それではテストを実行してみましょう。以下のコマンドを実行します。

```
$ npm run test
```

テストが実行され、問題なく PASS したことがわかりました。(図1)

```
PASS  ./index.test.js
 ✓ 1と2を渡したとき、3を返す (1 ms)
```

これでテストを実行する環境を構築できました。

なお、テストが PASS したときは「テストが成功した」「テストが通った」「テストがグリーンである」、FAIL した場合は「テストが失敗した」「テストが落ちた」「テストがレッドである」と言うのが一般的です。この記事では、主にテストが PASS した場合は「テストが通った」、FAIL したときは「テストが落ちた」と表現します。

## エラーの表示を確認する
（先日、案を提出した際に「エラーの表示も第2章で確認したい」ご提案いただいたのですが、「テストの分類」を書いたところ分量が多くなったこと、また第3章でエラーの画面を紹介するので、第2章でエラー画面はとりあえず書かなくても良いかなと思いました）

# GitHub Actions でコードを push する度にテストを実行する
（櫛引コメント: せっかくなので CI の考え方も書いておきたいのですが、紙面に余裕がない場合はこの節を削ってしまってもいいかもしれません）

## 継続的インテグレーション
毎回自分でテストを実行するのは手間がかかります。また、せっかくテストがあるのに実行を忘れてしまい、バグが含まれているコードをデプロイしてしまうのは避けたいことです。

そこで、新しく追加したコードがソフトウェアを壊していないことを確認するために、プルリクエストを作成する際やコードをデプロイする前にテストを自動で実行する一般的です。これを継続的インテグレーション（Continuous Integration。CI）と言います。

本章の最後に、GitHub Actions を利用してコードを push する度にテストを実行する設定をしましょう（注釈）。ただし、CI の設定は必須ではないためこの手順をスキップして第3章に進んでも構いません。

（注釈）CI ツールとしては GitHub Actions の他にも Circle CI や Travis CI、GitLab をお使いの方は GitLab CI などのサービスが利用可能です。

## GitHub Actions
`.github/workflows/test.yml`というファイルを作成し、以下の設定を記述します。

```
name: TDD JS Sample CI

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x]

    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: 16.x
        cache: 'npm'
    - run: npm ci
    - run: npm test
```

コミットをプッシュし、GitHub のレポジトリの Actions のページでテストが実行されていることが確認できます。（図: GitHub Actions）これで自動テストの準備ができました。
