---
title: "2"
date: "2022-01-15T18:37:05.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/tdd-2"
category: ""
tags:
    - ""
description: ""
socialImage: "/media/2022/01/15/2022_01_15__0.png"
---

第２章 ローカルでテストをする環境を作る

# テストの分類
この章ではテストの一般的な分類を解説した後、ローカルでテストを実行する環境を構築した後、GitHub Actions でテストの実行を自動化します。テストにはユニット（単体）テスト、インテグレーション（結合）テストや E2E テストなどテスト対象・方法に応じた様々な分類があります。それらを簡単に説明した後、テスティングフレームワークである Jest を用いて JavaScript のユニットテストを実行できる環境を構築します。

## ユニット（単体）テスト
ユニットテストは単体テストとも呼ばれます。これはテストの対象を1つの関数や1つのクラスに絞っている粒度の小さい独立したテストです。このユニットテストこそ TDD で記述する主なテストです。また、本章の後半でサンプルとして掲載しているテストコードもユニットテストなので、先に○ページのコード（テストコード）を見ていただくと理解が進むかもしれません。

## インテグレーション（結合）テスト
インテグレーションテストは結合テストとも呼ばれます。これはユニットテストとは異なり、複数の関数やクラスを対象としたテストであるため粒度が大きいテストです。また、データベースやネットワークなどソフトウェア経由でデータを読み書きするテストなど、自身の外側とやり取りをするようなものもインテグレーションテストに分類されます。インテグレーションテストを書く際にモックを使うこともあります。（この行の最後の一文は、モックを使ったことがある人にはイメージしやすいと思うのですが、記述がちょっと不正確かなと思うので削ってもいいかもしれません。）

## その他のテスト
ユニットテストやインテグレーションテストの他にもテスト方法や対象に応じた様々なテストがあります。いくつか例を挙げると、仕様要求に近い形でテストを記述する Behavioral Test（振る舞いテスト）や、システム全体を統合して期待通りの動きをすることをテストするE2Eテスト（End to End Testing。Web サイトであればテストにブラウザを使います）、コードの変更前と変更後の画面のスクリーンショットを撮影し、前後の画像を比較することで UI の差異の有無を発見するビジュアルリグレッションテスト（Visual Regression Test。フロントエンドで HTML や CSS の差分を確認するために使われます）、ソフトウェアの仕様を把握したり品質向上のため想定外のバグを発見するために行う探索的テスト（Exploratory Testing）などがあります。

なお、ユニットテストではなく振る舞いのテストを書くことで開発をする TDD から派生した BDD（Behavior Driven Development）という技法もあります。

# テストの捉え方
次に、ユニットテスト、インテグレーションテスト、E2E（UI）の各テストの関係に対する2つの考え方であるテストピラミッドとテスティングトロフィーを紹介します。

## テストピラミッド
テストピラミッドは Mike Cohn 氏が考案したとされ、幅広く受け入れられている考え方です（図: Test Pyramid。）。図中のサービステストはユニットテストより粒度が大きく、UIテストより粒度が小さいテストです。ピラミッドの下のテストほど実行速度が速くて粒度が小さいですがカバー範囲は狭いです。上のテストほど実行速度が遅くて粒度が大きいですが、カバー範囲は広くなります。ピラミッドの幅はテストの数であり、粒度の小さいテストほどたくさん記述し、粒度が大きいものは相対的に記述数が少なくなるということを表しています。（注釈）

（注釈）https://martinfowler.com/articles/practical-test-pyramid.html

## テスティングトロフィー
テスティングトロフィーは Kent C. Dodds 氏が考案したフロントエンドのアプリケーションにおけるテストの考え方です（図: Testing Trophy）。これは現代のフロントエンドエンジニアの間で支持されています。トロフィーの下の方は粒度やコストが小さく実行時間が短いという点はテストピラミッド同じですが、特にインテグレーションテストを多く書くと効率が良いというところと、型の検査や Lint など静的解析をテストの一種として加えているところに特色があります。

https://testingjavascript.com/
https://kentcdodds.com/blog/static-vs-unit-vs-integration-vs-e2e-tests

# ローカルでテストを実行する環境の構築
## 使用言語とテストツールの選定
TDDを実践する前に、この章ではローカルでテストを実行できる環境を構築します。今回は使用言語にJavaScript（Node.js）を、テスティングフレームワークにJestを選択し、ユニットテストを実行できるようにします。

本記事では Node.js は16.13.2を、Jest は27.4.7のバージョンを使用しています。

また、ローカルでの環境構築の手順をスキップしたいのであれば、Web 上でコードのテストができる cyber-dojo（注釈1）でテストを作成、実行しても構いません。（注釈2）

（注釈1）https://cyber-dojo.org/creator/home
（注釈2）ページにアクセスして「create a new practice > skip > JavaScript, jest > solo > ok」の順に進んで行き、「test」をクリックするとJestでのテストが実行されます。

## ツールの導入とローカルでの環境構築
ここからはコマンドを実行してテストの実行環境を構築していきます。まずはプロジェクトを作成するため、以下のコマンドを実行します。

`$ npm init -y`

package.jsonが作成されました。次にJestを導入します。

`$ npm install --save-dev jest`

packae.json の devDependencies に Jest が追加されたため、ローカルで Jest が実行可能になりました。

```
"devDependencies": {
  "jest": "^27.4.7"
}
```

（Node.jsのインストール方法も書いた方がいい？nodebrewを使う）
（npm,package.jsonの説明もした方がいい？）

## （文字数に余裕があれば）テストケースとツールのユースケースを比較する


# 最初のユニットテストを作成する
## テストを作成する
Node.jsでテストを実行する環境を構築できたので、実際に簡単なテストを記述してJestが動作することを確認してみましょう。プロジェクト配下に`index.js`と`index.test.js`を作成します。

```
$ touch index.js index.test.js
```

まずはindex.jsに受け取った引数を足し算する関数`add`を作成します。

```
function add(a, b) {
  return a + b;
}

module.exports = add
```

次に、index.test.jsにテストを記述します。

```
const add = require('./index')

test('1と2を渡したとき、3を返す', ()=> {
  expect(add(1, 2)).toBe(3);
});
```

この記事ではテスト名を日本語で記述します。各テストは「〇〇なとき、□□を返す」という状況と結果を表現する書き方をします。

## テストを実行する
### package.json にコマンドの記述を追加する
次に、package.jsonのscriptsのtestを`jest`に書き換えます。

```
"scripts": {
  "test": "jest"
}
```

これで`npm run test`を実行するとJestを動かすことが可能になります。

### テストコマンドを実行する
それではテストを実行してみましょう。

`$ npm run test`

テストが実行され、ちゃんとPASSしたことがわかりました。(図1)

```
PASS  ./index.test.js
 ✓ 1と2を渡したとき、3を返す (1 ms)
```

なお、一般的にテストがPASSしたときは「テストが成功した」「テストが通った」「テストがグリーンである」、FAILした場合は「テストが失敗した」「テストが落ちた」「テストがレッドである」と言うこともあります。この記事では、テストがPASSした場合は「テストが通る」、FAILしたときは「テストが落ちる」と表現します。

## エラーの表示を確認する
（先の案を提出した際に「エラーの表示も第2章で確認したい」ご提案いただいたのですが、「テストの分類」を書いたところ分量が多くなったこと、また第3章でエラーの画面を紹介するので、第2章でエラー画面はとりあえず不要かなと思いました。もし紙面に余裕があれば掲載しようと思います）

# GitHub Actions で push するたびにテストを実行する
## 継続的インテグレーション
手元でテストを実行するのは手間がかかります。また、せっかくテストを書いているのにテストの実行を忘れてしまい、バグが出ているコードをリリースするのは避けたいことです。そこで、プルリクエストを作成する際やコードをデプロイする前などに、テストを自動で実行して新しく追加したコードがソフトウェアを壊していないことを確認することが一般的です。これを継続的インテグレーション（Continuous Integration。CI）と呼びます。本章の最後に、GitHub Actions を利用して、コードを push する度にテストを実行する設定をしましょう。

（注釈）CI ツールとしては GitHub Actions の他にも Circle CI や Travis CI、GitLab をお使いの方は GitLab CI などのサービスが利用可能です。

## GitHub Actions
`.github/workflows/test.yml`というファイルを作成し、以下の設定を記述します。

```
name: TDD JS Sample CI

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x]

    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: 16.x
        cache: 'npm'
    - run: npm ci
    - run: npm test
```

コミットをプッシュし、GitHub のレポジトリの Actions のページでテストが実行されていることが確認できます。（図: GitHub Actions）これで自動テストの準備ができました。
