---
title: "3"
date: "2022-01-15T18:37:05.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/tdd-3"
category: ""
tags:
    - ""
description: ""
socialImage: "/media/2022/01/15/2022_01_15__0.png"
---

第3章 TDD に挑戦してみよう

# レッド、グリーン、リファクタリングのサイクル
## レッド
TDDでは「落ちるテストを書く」ことが最初の一歩です。実装したい関数のテストだけを先に書いてテストを実行します。このステップをレッドと呼びます。

(「自動化されたテストが失敗したときのみ、新しいコードを書く」ということを盛り込みたい)

テストを先に記述するのはまだ理解できるとしても、テスト対象が未実装であるのにテストを実行すると必ず失敗する。失敗するのがわかっているのにテストを実行する必要があるのか、と考える方もおられると思います。

また、このレッドは「テストが落ちるのは、実装したプログラムが壊れていると言うことだ。テストが落ちるのはなんとなく怖いし、落ちるテストを見たくない」というプログラマの直感に反するステップです。

プログラムを実行してエラーメッセージが表示されたら「怒られた」と表現する人もいますが、本来プログラムのエラーメッセージは実行に失敗したことを適切なタイミングでフィードバックしてくれるものです。

適切にハンドリングされたエラーは実装者がプログラムを正しく実装するにあたってうまくいっていない点を教えてくれる有用なメッセージです。

TDDでの開発はこのエラーメッセージを活用することで次にするべきことを明確にし、寄り道せずに最短距離で進むことを支援してくれます。記事の後半で実際に実装を進めていくうちにこの感覚を掴んでいきましょう。

## グリーン
グリーンのステップでは、レッドで書いたテストを最短で通すように実装をします。TDDの目標は「動作するきれいなコード」を書くことでした。まずは「動作するコード」書くために、値をハードコーディング（ベタ書き）してでもテストを通すようにします。

ハードコーディングというと好ましいものではないと思われますが、これは「仮実装」という歴としたTDDのテクニックの1つです。まずはテストを通すことにより、コードが動くことを確認します。もちろんハードコーディングをして終わりというわけではありません。ここでは実装を抽象化する前に、具体的な値を当てはめて意図通り動作することを確認するためのハードコーディングです。

なお、稀に実装ではなくアサーションなどテストの方が間違っている場合があります。その場合でも最短で実装することで早い段階でテストを修正できます。程よく抽象化されてロジックにもバグがない実装に見えるのにテストが落ちていて、時間をかけてテストのデバッグを進めるとテストが間違っていることがわかり拍子抜けするといったことが避けられるのです。

さて、グリーンでは動作するコードを実装しました。このコードを綺麗なコードにするために、次のリファクタリングのステップへと進みます。なお、レッドは赤信号であり一旦立ち止まって実装を進めるというサイン、対してグリーンはコードが動くことがわかったのでリファクタリングに進んでも良いという青信号のサインと捉えて貰っても良いかと思います。

## リファクタリング
リファクタリングのステップではテストを通すために生じた重複の除去を行います。リファクタリングは一般的に「ソフトウェアの外部の振る舞いを保ったままで、内部の構造を改善していく作業」（注釈1）を指します。TDDではソフトウェアの外部の振る舞いが保たれていることをテストで担保しているため、テストが通っている間は安心して実装を書き換えられます。

このステップではテストを何度も実行することになるでしょう。自分が書き換えたコードに不安を感じたらテストを実行して、プログラムが壊れていないかすぐにチェックできます。ブラウザを立ち上げて挙動を確認したり、変数の中身を標準出力に表示して確認する手間がなくなります。テストが通っていることを確認できるため、自信を持ってソフトウェアをリリースできます。

また、リファクタリングの過程でテストが落ちてしまったら、テストが落ちる前のコードに戻します。そしてまた新しく別の実装方法を考えます。

なお、このステップはあくまでリファクタリングであるので、ここで実装に新しい機能を盛り込むことは避けましょう。その場合は先にテストを書いてレッドのステップに進んでください。また、境界値の判定ロジックなど自分が書いたコードに自信が持てない場合も新たにテストを書いていきます。全ての実装が完了した場合は、このステップで開発終了です。

（注釈1）『リファクタリング　既存のコードを安全に改善する』（第二版） Martin Fowler著・Ohmsha（2019年）

## 一歩ずつ着実に進む
TDDを実践することにより、コードを書くに当たり「一歩ずつ着実に進む」という感覚を得られます。この感覚を持つことは、自分が書いているプログラムはバグを含んでいないという自信、引いては誇りに繋がります。

ここでいう一歩ずつとは、レッド、グリーン、リファクタリング、レッド...と1つずつTDDの開発プロセスを進めることを指します。また、着実とは、エラーが表示されると事前に予想してテストが落ち、テストが成功すると予想してその通りにグリーンになることです。

テストが通ると思って実際グリーンになるということはもちろん良いことです。しかし、仮にテストが落ちたとしても「この実装はエラーになるだろう」と予想した上でのことであれば、これもまた良い開発状態です。なぜなら、自分がソフトウェアの振る舞いを正確に把握していることになるからです。そして、その状態であれば自分が書くコードに不安はないはずです。

このように、TDDでは小さなフィードバックサイクルを高速で回していくことで、自信を持ってコードを書いていくことができます。


（文字数）






# FizzBuzzをTDDで実装する
本章ではTDDでの開発を実践します。TDDの目標は「動作するきれいなコード」を書くことです。つまり、エンジニアの書くコードが「動作するけど汚いもの」や「きれいだけど動かないもの」にならないようにすることがゴールです。

書籍『テスト駆動開発』によると、この目標を実現するために以下のルールを設けているということです。

・自動化されたテストが失敗したときのみ、新しいコードを書く
・重複を除去する（リファクタリングする）

TDDのルールはたった2つだけです。前者で動くコードを書き、後者で綺麗なコードを書くのです。このルールを守りながら実装を進めるために、TDDでは「レッド・グリーン・リファクタリング」というステップを繰り返して開発していきます。

## TODOリストとレッド・グリーン・リファクタリング
レッド・グリーン・リファクタリングをさらに具体化すると以下のようなステップに分けられます。（注釈）

1. 目標をTODOリストとして書き出す
2. TODOリストから1つピックアップし、テストを書く
3. テストコードを実行して失敗させる（レッド）
4. 実装コードを書く
5. できる限り最短でテストが通るコードを実装する（グリーン）
6. テストが通るままでリファクタリングをする（リファクタリング）
7. 次のTODOを選び、2に進む

この一連のステップをたどることで、上記のルールを守りながら自然にソフトウェアを開発できます。では実際にTODOリストを作成しましょう。

(注釈: 「50分でわかるテスト駆動開発 / TDD Live in 50 minutes」9ページを元に改変 https://speakerdeck.com/twada/tdd-live-in-50-minutes?slide=9)

## TODOリストを用意する
今回実装するのはFizzBuzzです。FizzBuzzとは、3の倍数を渡したときにFizzを、5の倍数ではBuzzを、15の倍数ではFizzBuzzに変換します。その他の数字を渡したときはその数字を返すプログラムのことです。

実際にコードを書く前に仕様からTODOリストを作成します。

- [ ] 数を文字列に変換する
    - [ ] 1を渡すと文字列"1"を返す
    - [ ] 2を渡すと文字列"2"を返す
- [ ] 3の倍数を渡すと「Fizz」を返す
    - [ ] 3を渡すと文字列「Fizz」を返す
- [ ] 5の倍数を渡すと「Buzz」を返す
    - [ ] 5を渡すと文字列「Buzz」を返す
- [ ] 15の倍数を渡すと「FizzBuzz」を返す
    - [ ] 15を渡すと文字列「FizzBuzz」を返す

なお、このリストはゴールまで見据えた完成形ですが、テストや実装をしている段階でリストからタスクを増減させることは問題ありません。仕様に対するフィードバックが発生しており、むしろ好ましいことです。

ではTODOリストに基づき、早速実装していきましょう。なお、手を動かすにあたり、図のようにエディタで実装コードとテストのファイルを同時に表示しておくことをオススメします。（図: editor）

# 数を文字列に変換する
最初はTODOリストから一番簡単なタスクを選択します。初めはテストの実行環境を整えたり、テストファイルを作成したり、実装に入る前の準備が多いからです。ここでは、TODOリストの一番上のタスクを選択します。

## 1を渡すと文字列"1"を返す
テストの実行環境は前章のものを使い回しましょう。add関数のテストを作成したときに使ったindex.jsとindex.test.jsのファイルを空にします。これで準備ができました。

### レッド
それでは最初のテストを書きます。ここでは落ちるテストをindex.test.jsに記述します。

```
test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  // 検証（Assertion）
  expect('1').toBe(actual);
});
```

この記事ではテスト名を日本語で記述しています。テスト名は生きた仕様書であるため、開発者が日本のメンバーであればドキュメントと同様に日本語を使うと良いでしょう。

`$ npm run test`を実行してこの状態でテストを動かしましょう。ただし、この状態ではテストが落ちるのは容易に想像できます。実際、`ReferenceError: actual is not defined`(actualが未定義)というエラーが表示されました（図2）。しかし、この段階で1つ確認できたことがあります。それは、テストが問題なく実行できるということです。

なお、コードコメントに準備、実行、検証と書いています。これはテストで頻出するパターンなのですが、TDDではプログラマの直感に反して検証→実行→準備の順に実装していきます。これは検証を一番最初に書くことでテストのゴールを明確にするためです。

今回はシンプルな関数なので準備の記述はありませんが、準備ではクラスのメソッドをテストするのであればクラスの初期化や引数に渡すデータを用意することが一般的です。

ではもう少し先に進みましょう。fizzBuzz関数をテストで実行します。

```
test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  const actual = fizzBuzz(1);
  // 検証（Assertion）
  expect('1').toBe(actual);
});
```

テストを動かします。するとエラーの内容が`ReferenceError: fizzBuzz is not defined`（fizzBuzzが未定義）に変わりました。fizzBuzz関数を作成していないから当然なのですが、このエラーを改めて読むと次に何をすればいいか教えてくれていることになります。

また、今回はfizzBuzzというシンプルな関数でありそれほど意識することはないですが、少し複雑な関数やメソッドをテストする場合、テスト対象を実装する前にテストで使うことで利用者が理解しやすい命名や引数の設計が可能になります。

次にテストを書き換え、`index.js`でfizzBuzz関数を作成します。

```
// index.test.js
const fizzBuzz = require('./index');

test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  const actual = fizzBuzz(1);
  // 検証（Assertion）
  expect('1').toBe(actual);
});
```

```
// index.js
function fizzBuzz(num) {
  return null;
}

module.exports = fizzBuzz;
```

テストを実行します。「Expected: null. Received: "1".」というエラーが表示され、fizzBuzz関数を参照できていることがわかりました。

### グリーン
次に、最短でこのテストをグリーンにするようにfizzBuzz関数を実装します。

```
function fizzBuzz(num) {
  return '1';
}
```

これでコマンドを実行するとテストが通りました（図3）。本当にそれでいいのかと疑問を持つ方もおられるでしょうが、これは「仮実装」と呼ばれるTDDのテクニックなのです。最短でテストを通すことで、実装者は安心が得られるだけでなくテストコードが間違っていないことも確認できます（実際、著者が執筆中に最初のコードで`expect(1)`と文字列ではなく数値を期待するコードを書いており、仮実装のテストによってテスト側にバグが盛り込まれていることに気付きました）。

### リファクタリング
テストがグリーンになったのでリファクタリングを行います。コメントを消して、fizzBuzzの返り値を変数に格納するのをやめましょう。すると`index.test.js`は以下のようになります。

```
const fizzBuzz = require('./index');

test("1を渡すと文字列'1'を返す", () => {
  expect('1').toBe(fizzBuzz(1));
});
```

テストを実行してもグリーンのままです。リファクタリングが安全に完了しました。これ以上やることがなくなったので1サイクル目は終わりです。次にTODOリストから「2を渡すと文字列"2"を返す」というタスクを進めていきましょう。

- [ ] 数を文字列に変換する
    - [x] 1を渡すと文字列"1"を返す → 仮実装
    - [ ] 2を渡すと文字列"2"を返す

## 2を渡すと文字列"2"を返す
### レッド
`index.test.js`に落ちるテストを追加します。

```
test("2を渡すと文字列'2'を返す", () => {
  expect('2').toBe(fizzBuzz(2));
});
```

`$ npm run test`でテストを実行します。今度は「Expected: "1".Received: "2"」というエラーが出ました。テストが落ちてレッドになったので、fizzBuzz関数の実装を進めていきます。

### グリーン
グリーンのステップでは最短でテストが通るように実装します。TODOリストを見ると1、2を渡された場合のタスクがあります。具体的な数値の例が2つあるため、処理を一般化してみましょう。これをTDDのテクニックで「三角測量」と呼びます。処理を一般化する方法がはっきりわからないときに、具体的な値を渡すテストを2つ作成し、実装方法を探るのです。

JavaScriptで数値を文字列に変換するメソッドは`toString()`です。これを活用して引数を文字列に変換しましょう。

```
function fizzBuzz(num) {
  return num.toString();
}
```

テストを実行すると問題なくPASSしました。

### リファクタリング
さて、リファクタリングのステップですが、今回は特にすることがありません。TODOリストのタスクに完了の印をつけて次に進みましょう。

- [x] 数を文字列に変換する
    - [x] 1を渡すと文字列"1"を返す → 仮実装
    - [x] 2を渡すと文字列"2"を返す → 三角測量

# 3の倍数を渡すと「Fizz」を返す
## 3を渡すと文字列「Fizz」を返す
次にTODOリストから「3を渡すと文字列『Fizz』を返す」というタスクを選択します。

### レッド
まずはテストを追加します。

```
test("3を渡すと文字列'Fizz'を返す", () => {
  expect('Fizz').toBe(fizzBuzz(3));
});
```

テストを実行すると「Expected: "3".Received: "Fizz"」と表示され、テストが失敗しましたのでグリーンに進みます。

### グリーン
ここでは最短でテストが通る実装します。再び仮実装のテクニックを使い、テストをグリーンにしてリファクタリングに進みましょう。

```
function fizzBuzz(num) {
  if (num === 3) {
    return 'Fizz';
  }
  return num.toString();
}
```

### リファクタリング
テストが通ったのでリファクタリングをします。今回はまずテストコードを構造化します。現在の`index.test.js`は以下です。

```
test("1を渡すと文字列'1'を返す", () => {
  expect('1').toBe(fizzBuzz(1));
});

test("2を渡すと文字列'2'を返す", () => {
  expect('2').toBe(fizzBuzz(2));
});

test("3を渡すと文字列'Fizz'を返す", () => {
  expect('Fizz').toBe(fizzBuzz(3));
});
```

最初の2つのテストと最後のテストは毛色が異なります。このため、TODOリストの構造とテストの構造を合わせるためにdescribe関数を使います。

```
describe('数を文字列に変換する', () => {
  test("1を渡すと文字列'1'を返す", () => {
    expect('1').toBe(fizzBuzz(1));
  });

  test("2を渡すと文字列'2'を返す", () => {
    expect('2').toBe(fizzBuzz(2));
  });
});

describe('3の倍数を渡すと「Fizz」を返す', () => {
  test("3を渡すと文字列'Fizz'を返す", () => {
    expect('Fizz').toBe(fizzBuzz(3));
  });
});
```

テストを実行するとテスト結果にTODOリストの階層が反映されていいることがわかります（図4, 5）。

また、数値が3の倍数か判定する方法は明確です。この段階でベタ書きの値を使うのをやめて、本実装をしましょう。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  }
  return num.toString();
}
```

テストを実行するとグリーンのままです。リファクタリングが完了したので、タスクにチェックをつけて次に進みます。

- [x] 3の倍数を渡すと「Fizz」を返す
    - [x] 3を渡すと文字列「Fizz」を返す -> 仮実装 -> 実装


# 5の倍数を渡すと「Buzz」を返す
##  5を渡すと文字列「Buzz」を返す
次に「5を渡すと文字列『Buzz』を返す」というタスクに取り組みます。

### レッド
そろそろレッド、グリーン、リファクタリングのリズムに慣れてきた頃でしょうか。落ちるテストを追加します。

```
describe('5の倍数を渡すと「Buzz」を返す', () => {
  test("5を渡すと文字列'Buzz'を返す", () => {
    expect('Buzz').toBe(fizzBuzz(5));
  });
});
```

テストを実行するとちゃんとレッドになりました。

### グリーン
今回のタスクは先ほどの3の倍数を渡すとFizzを返すタスクと似ており実装方針が明確です。このため、今回は仮実装をせずに先ほどと同様に実装しましょう。TDDではこの実装方法に「明白な実装」と名前をつけています。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  }
  if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンになるため、次に進みます。

### リファクタリング
今回のリファクタリングでは2つのif文をif~elseに変更します。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  } else if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンのままです。TODOリストにチェックをつけて次に進みます。

- [x] 5の倍数を渡すと「Buzz」を返す
    - [x] 5を渡すと文字列「Buzz」を返す → 明白な実装

# 15の倍数を渡すと「FizzBuzz」を返す
##  15を渡すと文字列「FizzBuzz」を返す
いよいよ最後のタスクです。「15を渡すと文字列『FizzBuzz』を返す」タスクを実装していきます。

### レッド
タスク名をテスト名に使って、落ちるテストを追加します。

```
describe('15の倍数を渡すと「FizzBuzz」を返す', () => {
  test('15を渡すと文字列「FizzBuzz」を返す', () => {
    expect('FizzBuzz').toBe(fizzBuzz(15));
  });
});
```

テストを実行すると「Expected: "Fizz".Received: "FizzBuzz".」というエラーが表示されましたので次に進みます。

### グリーン
今回もこれまでと同様の条件判定を使って仕様を実現できるため、仮実装を飛ばして明白な実装をします。

```
function fizzBuzz(num) {
  if (num % 3 === 0 && num % 5 === 0) {
    return 'FizzBuzz';
  }
  if (num % 3 === 0) {
    return 'Fizz';
  } else if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンになりました。

### リファクタリング
最後のリファクタリングを行います。リファクタリングの基本は重複の除去でした。今回、実装コードでは3と5の倍数の判定が重複しています。これを変数に切り出しましょう。

```
function fizzBuzz(num) {
  const canDivideByThree = num % 3 === 0;
  const canDivideByFive = num % 5 === 0;

  if (canDivideByThree && canDivideByFive) {
    return 'FizzBuzz';
  } else if (canDivideByFive) {
    return 'Fizz';
  } else if (canDivideByThree) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行してみます。すると「3を渡すと文字列'Fizz'を返す」「5を渡すと文字列'Buzz'を返す」という2つのテストが落ちてしまいました（図6）。エラーメッセージを読んでみると、3のときにBuzzを、5のときにFizzを返しています。

リファクタリングの際にテストが落ちてしまうことは珍しいことではありません。そんな時は一度リファクタリングを止めてエラーの原因を探します。実装コードを見るとif文の条件で使用している変数が反対になっていました。変数を入れ替えて再度テストを実行します。

```
function fizzBuzz(num) {
  const canDivideByThree = num % 3 === 0;
  const canDivideByFive = num % 5 === 0;

  if (canDivideByThree && canDivideByFive) {
    return 'FizzBuzz';
  } else if (canDivideByThree) {
    return 'Fizz';
  } else if (canDivideByFive) {
    return 'Buzz';
  }
  return num.toString();
}
```

今度はテストがグリーンになり、リファクタリングが完了しました。

- [x] 15の倍数を渡すと「FizzBuzz」を返す
    - [x] 15を渡すと文字列「FizzBuzz」を返す → 明白な実装

これで TDD で fizzBuzz 関数が実装できました。`index.test.js`は以下のようになっています。

```
const fizzBuzz = require('./index');

describe('数を文字列に変換する', () => {
  test("1を渡すと文字列'1'を返す", () => {
    expect('1').toBe(fizzBuzz(1));
  });

  test("2を渡すと文字列'2'を返す", () => {
    expect('2').toBe(fizzBuzz(2));
  });
});

describe('3の倍数を渡すと「Fizz」を返す', () => {
  test("3を渡すと文字列'Fizz'を返す", () => {
    expect('Fizz').toBe(fizzBuzz(3));
  });
});

describe('5の倍数を渡すと「Buzz」を返す', () => {
  test("5を渡すと文字列'Buzz'を返す", () => {
    expect('Buzz').toBe(fizzBuzz(5));
  });
});

describe('15の倍数を渡すと「FizzBuzz」を返す', () => {
  test('15を渡すと文字列「FizzBuzz」を返す', () => {
    expect('FizzBuzz').toBe(fizzBuzz(5));
  });
});
```

## 意図が不明瞭で重複したテストを削除する
TDD で開発を進めるとテストケースが増加します。いくら実行時間の短いユニットテストであっても、数が増加すれば実行時間も同時に増えていきます。テストケースが増えて CI の実行時間が長引いた場合、テストの実行を並列化したり、コードに変更がない場合にテストをスキップするといったテクニックが存在します。

しかし、そもそも不要なテストを削除することも1つの手段です。fizzBuzz 関数の場合、「2を渡すと文字列'2'を返す」というテストケースは三角測量のために作成したテストです。実装を進める過程で一般化が完了しているため、「1を渡すと文字列'1'を返す」というテストと役割が重複しています。後からプロジェクトに参加した他のエンジニアが「このテストは一見不要に見えるが、残っているのは何らかの意図があるのだろう」と考えると、そのテストは永遠に残されます。このため「2を渡すと文字列'2'を返す」というテストは削除しても構いません。これでテストのメンテナンスコストを少し減らせました。

# TDD がもたらす効果
## TDDの目的はコードに対する自信
TDD で fizzbuzz 関数を実装することで、実装にバグを含んでいないという自信を持つことができたのではないでしょうか。五里霧中な未知の世界から、一歩ずつ既知の世界へ進んでいく。エンジニアはソフトウェアの動作を深く把握しているため、不安なくリリース可能になります。これこそが TDD がエンジニアにもたらす最大の効果です。

## TDD はテスト技法ではない
ただし、TDD で実装しているからと言ってソフトウェアにバグが全く発生しないわけではありません。実際、TDD の考案者である Kent Beck も以下のように述べています。

「皮肉なことに、TDDはテスト技法ではない。TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。」（注:『テスト駆動開発』p.278）

TDD は主にユニットテストを記述し、クラスや関数を作る前に使うことで自然とテストしやすい設計にする手法です。 注意するべきは、TDDだからといってバグが全てなくなるわけではないということです。エンジニアが想定したテストケースを通った実装であっても、ユーザーがソフトウェアを思わぬ使い方をしたり探索的テストを通してバグが見つかる可能性はゼロではありません。

例えば、先ほど実装した fizzBuzz 関数の引数に文字列や null など数値以外の値を渡せばエラーになります。このようにもし実装に不安があるなら、さらにテストケースを足して不安を解消しましょう。

# 現場で TDD を実践するために
実際の仕事の現場で TDD を実践するためのコツを3つご紹介します。

## チームでテストを実行する環境を構築する
TDD は自分一人で始められる個人的な技法ですが、現場ではチーム開発がほとんどでしょう。もし現行のプロジェクトでテストを実行する環境が整っていない場合、使用言語に応じたテスティングフレームワークを選定したり、CI 環境の構築が先決です。チームメンバーを巻き込んで、ときにインフラや基盤チームなど周囲の助けを借りながら環境の構築をすることが第一歩です。

## 既存のプロジェクトにテストを書き足す
テストのない既存のプロジェクトで初めてテストを追加する際は、以下の2つのテクニックを活用できます。

### バグが発生した時にテストを書いてバグを再現する
1つ目は、バグが発生した際にそのバグを再現するテストを記述することです。そして、テストが通るように実装を書き換えれば同様バグは二度と起こらなくなる上に、今後手動で動作を確認する必要もなくなります。

これについて、私が現場で経験したエピソードをご紹介します。フロントエンドのアプリケーションを TDD で実装したときに画面の表示でバグが1件発生しました。それは検索ワードを検索結果でハイライトする処理で、複数の単語を検索ワードとしたときに2つ目以降の単語がハイライトされていないという現象でした。その際、まずバグを再現するテストケースを追加して、ハイライトのロジックを書き換え、テストが通ることを確認してリリースしました。その後、二度と同様のバグは起きませんでした。

### テストのない既存機能の改修前にテストを書く
2つ目は、既存機能の改修に当たりテストを書くことです。新規機能開発であれば最初からテストを書けばよいですが、テストのない既存機能に手を加える必要がある場合、動作の把握のためやリファクタリングを見据えてテストを記述してみましょう。もし既存のコードが複雑な処理をしていれば、テストを書くことで安心してリファクタリングが可能になります。そして、リファクタリングをした後に既存の機能を改修してみましょう。実際の現場では、工数管理をするプロジェクトマネージャーに対して機能開発時にリファクタリングの工数も見積もりに含めるなど調整が必要になります。しかし、リファクタリングをした後は簡単に機能が追加でき、自信を持ってコードを記述できると感じられるはずです。

何よりテストがあることでリリース毎にユーザーにバグを届ける割合が減り、バグ発生のアラートが届く回数が減り、既存機能のバグ修正のパッチを書くことに追われていた時間が減ります。結果、ユーザーに価値を届けることに集中できるようになります。

# おわりに
TDDでfizzBuzzを実装してみました。普通に実装するのとは異なり、自分のコードに対する自信を持つことができたのではないでしょうか。今回は JavaScript を使いましたが、TypeScript のような静的型付け言語を使うとコンパイラがエラーを出してくれます。第2章のテスティングトロフィーにあるように、これも設計を駆動するテストの1つです。

今回実装したコードはGitHubで公開しています(注釈1)。余力があれば fizzBuzz 関数を使ったチャレンジとして、「数値以外の値を渡したとき、例外を発生させる」というテストを追加したり、リファクタリングとして倍数の判定を canDivideBy という関数に切り出してみてください。こちらも併せて GitHub で公開しています。

さらにTDDに対する理解を深めたい方は、私が本記事を執筆するにあたり参考にした @t_wada さんの TDD のライブコーディング動画もぜひご覧ください(注釈2)。実際に他の人がどのように実践しているかを知りたい、体験したい場合は勉強会（注釈:3）に参加するのも1つの手です。他にも TDD で別の課題に挑戦するのであれば、Bob Martin 氏が考案したボウリングゲームを実装してみるのもオススメです。（注釈 4）

(注釈1): https://github.com/KushibikiMashu/tdd-js-fizzbuzz
(注釈2): https://youtu.be/Q-FJ3XmFlT8
(注釈3): TDD Boot Camp https://tddbc.connpass.com/ や TDDワイワイ会 https://tddyyx.connpass.com/ などの勉強会があります。
(注釈4): https://oblac.rs/tdd-kuglanje-i-teca-bob/Bowling_Game_Kata.pdf

TDD は実装がないのに先にテストを記述したり、テストケースで最初に検証から書いたり、エラーが起きない限り実装を進めないなどエンジニアの直感に反するアクティビティです。しかし、TDD は個人的な技法であるため誰でもすぐに始められます。TDD の考案者である Kent Beck 氏はこのように述べています。「私は偉大なプログラマではない。偉大な習慣を身につけたプログラマだ。」みなさんも TDD という直感に反する偉大な習慣を身につけて、自信を持ってソフトウェアをリリースしていきましょう。この記事がみなさんのエンジニア活動のお役に立てれば幸いです。

参考
- テスト駆動開発
