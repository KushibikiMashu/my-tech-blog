---
title: "3"
date: "2022-01-15T18:37:05.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/tdd-3"
category: ""
tags:
    - ""
description: ""
socialImage: "/media/2022/01/15/2022_01_15__0.png"
---

第3章 TDD に挑戦してみよう

# TDDのレッド・グリーン・リファクタリングのサイクル
## レッド
TDDでは「落ちるテストを書く」ことが最初の一歩です。実装したい関数のテストだけを先に書いてテストを実行します。このステップをレッドと呼びます。

(「自動化されたテストが失敗したときのみ、新しいコードを書く」ということを盛り込みたい)

テストを先に記述するのはまだ理解できるとしても、テスト対象が未実装であるのにテストを実行すると必ず失敗する。失敗するのがわかっているのにテストを実行する必要があるのか、と考える方もおられると思います。

また、このレッドは「テストが落ちるのは、実装したプログラムが壊れていると言うことだ。テストが落ちるのはなんとなく怖いし、落ちるテストを見たくない」というプログラマの直感に反するステップです。

プログラムを実行してエラーメッセージが表示されたら「怒られた」と表現する人もいますが、本来プログラムのエラーメッセージは実行に失敗したことを適切なタイミングでフィードバックしてくれるものです。

適切にハンドリングされたエラーは実装者がプログラムを正しく実装するにあたってうまくいっていない点を教えてくれる有用なメッセージです。

TDDでの開発はこのエラーメッセージを活用することで次にするべきことを明確にし、寄り道せずに最短距離で進むことを支援してくれます。記事の後半で実際に実装を進めていくうちにこの感覚を掴んでいきましょう。

## グリーン
グリーンのステップでは、レッドで書いたテストを最短で通すように実装をします。TDDの目標は「動作するきれいなコード」を書くことでした。まずは「動作するコード」書くために、値をハードコーディング（ベタ書き）してでもテストを通すようにします。

ハードコーディングというと好ましいものではないと思われますが、これは「仮実装」という歴としたTDDのテクニックの1つです。まずはテストを通すことにより、コードが動くことを確認します。もちろんハードコーディングをして終わりというわけではありません。ここでは実装を抽象化する前に、具体的な値を当てはめて意図通り動作することを確認するためのハードコーディングです。

なお、稀に実装ではなくアサーションなどテストの方が間違っている場合があります。その場合でも最短で実装することで早い段階でテストを修正できます。程よく抽象化されてロジックにもバグがない実装に見えるのにテストが落ちていて、時間をかけてテストのデバッグを進めるとテストが間違っていることがわかり拍子抜けするといったことが避けられるのです。

さて、グリーンでは動作するコードを実装しました。このコードを綺麗なコードにするために、次のリファクタリングのステップへと進みます。なお、レッドは赤信号であり一旦立ち止まって実装を進めるというサイン、対してグリーンはコードが動くことがわかったのでリファクタリングに進んでも良いという青信号のサインと捉えて貰っても良いかと思います。

## リファクタリング
リファクタリングのステップではテストを通すために生じた重複の除去を行います。リファクタリングは一般的に「ソフトウェアの外部の振る舞いを保ったままで、内部の構造を改善していく作業」（注釈1）を指します。TDDではソフトウェアの外部の振る舞いが保たれていることをテストで担保しているため、テストが通っている間は安心して実装を書き換えられます。

このステップではテストを何度も実行することになるでしょう。自分が書き換えたコードに不安を感じたらテストを実行して、プログラムが壊れていないかすぐにチェックできます。ブラウザを立ち上げて挙動を確認したり、変数の中身を標準出力に表示して確認する手間がなくなります。テストが通っていることを確認できるため、自信を持ってソフトウェアをリリースできます。

また、リファクタリングの過程でテストが落ちてしまったら、テストが落ちる前のコードに戻します。そしてまた新しく別の実装方法を考えます。

なお、このステップはあくまでリファクタリングであるので、ここで実装に新しい機能を盛り込むことは避けましょう。その場合は先にテストを書いてレッドのステップに進んでください。また、境界値の判定ロジックなど自分が書いたコードに自信が持てない場合も新たにテストを書いていきます。全ての実装が完了した場合は、このステップで開発終了です。

（注釈1）『リファクタリング　既存のコードを安全に改善する』（第二版） Martin Fowler著・Ohmsha（2019年）

## 一歩ずつ着実に進む
TDDを実践することにより、コードを書くに当たり「一歩ずつ着実に進む」という感覚を得られます。この感覚を持つことは、自分が書いているプログラムはバグを含んでいないという自信、引いては誇りに繋がります。

ここでいう一歩ずつとは、レッド、グリーン、リファクタリング、レッド...と1つずつTDDの開発プロセスを進めることを指します。また、着実とは、エラーが表示されると事前に予想してテストが落ち、テストが成功すると予想してその通りにグリーンになることです。

テストが通ると思って実際グリーンになるということはもちろん良いことです。しかし、仮にテストが落ちたとしても「この実装はエラーになるだろう」と予想した上でのことであれば、これもまた良い開発状態です。なぜなら、自分がソフトウェアの振る舞いを正確に把握していることになるからです。そして、その状態であれば自分が書くコードに不安はないはずです。

このように、TDDでは小さなフィードバックサイクルを高速で回していくことで、自信を持ってコードを書いていくことができます。


（文字数）






# TDDでFizzBuzzを実装する
本章ではTDDを実践してみます。TDDの目標は「動作するきれいなコード」を書くことです。つまり、エンジニアの書くコードが「動作するけど汚いもの」や「きれいだけど動かないもの」にならないようにすることがゴールです。

書籍『テスト駆動開発』によると、この目標を実現するために以下の2つのルールが設けられています。

・自動化されたテストが失敗したときのみ、新しいコードを書く
・重複を除去する（リファクタリングする）

TDD のルールはたった2つだけです。前者のルールに従って動くコードを書き、後者で綺麗なコードを書くのです。このルールを守りながら実装を進めるために、TDD では「レッド・グリーン・リファクタリング」というステップを繰り返して開発していきます。

## TODOリストとレッド・グリーン・リファクタリング
レッド・グリーン・リファクタリングをさらに具体化すると以下のようなステップに分けられます。（注釈）

1. 目標をTODOリストとして書き出す
2. TODOリストから1つピックアップし、テストを書く
3. テストコードを実行して失敗させる（レッド）
4. 実装コードを書く
5. できる限り最短でテストが通る実装をする（グリーン）
6. テストが通るままの状態でコードを書き換える（リファクタリング）
7. 次のTODOを選び、2に進む

この一連のステップを進めることで、上記のルールを守りながら自然にテンポ良くソフトウェアを開発できます。

(注釈: 「50分でわかるテスト駆動開発 / TDD Live in 50 minutes」（@t_wada） 9ページを元に改変 https://speakerdeck.com/twada/tdd-live-in-50-minutes)

## TODOリストを用意する
実際にTODOリストを作成してみましょう。今回実装するのはFizzBuzzです。FizzBuzzとは、3の倍数を渡したときに Fizz を、5の倍数では Buzz を、15の倍数では FizzBuzz に変換し、その他の数字を渡したときはその数字を返すプログラムのことです。

この FizzBuzz の使用に基づいてTODOリストを作成します。

- [ ] 数を文字列に変換する
  - [ ] 1を渡すと文字列"1"を返す
  - [ ] 2を渡すと文字列"2"を返す
- [ ] 3の倍数を渡すと「Fizz」を返す
  - [ ] 3を渡すと文字列「Fizz」を返す
- [ ] 5の倍数を渡すと「Buzz」を返す
  - [ ] 5を渡すと文字列「Buzz」を返す
- [ ] 15の倍数を渡すと「FizzBuzz」を返す
  - [ ] 15を渡すと文字列「FizzBuzz」を返す

なお、このTODOリストはゴールまで見据えた完成形ではありますが、実際にはより簡単なTODOリストを作成して、テストや実装の段階でTODOリストのタスクを増減させることは問題ありません。それは設計に対するフィードバックが発生しており、むしろ好ましいことです。

ではTODOリストに基づき、早速実装していきましょう。なお、手を動かすにあたり、図のようにエディタで実装コードとテストのファイルを同時に表示しておくことがオススメです。（図: editor）

# 数を文字列に変換する
テストの実行環境は前章のものを使い回しましょう。add 関数のテストを作成したときに使った index.js と index.test.js のファイルを空にします。

最初はTODOリストから一番テストしやすいタスクを選択します。今回は第2章で環境構築をしましたが、初めはテストの実行環境を整えたりテストファイルを作成したりと、実装に入る前の準備が多いためです。ここでは、TODOリストの一番上のタスクを選択します。

## 1を渡すと文字列"1"を返す
### レッド
それでは最初のテストを書きます。まず落ちるテストを index.test.js に記述します。Jest では expect に関数などの実際の返り値を、toBe に返してほしい値を書きます。

```
test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  // 検証（Assertion）
  expect(actual).toBe('1');
});
```

この記事ではテスト名を日本語で記述しています。テスト名は生きた仕様書であるため、開発者が日本のメンバーであれば日本語を使うと良いでしょう。

`$ npm run test`を実行してこの状態でテストを動かします。この状態ではテストが落ちるのは容易に想像できます。実際にテストを実行すると`ReferenceError: actual is not defined`(actualが未定義)というエラーが表示されました（図2）。

しかし、この段階で1つ確認できたことがあります。それはテストが問題なく実行できるということです。

なお、コードコメントに準備、実行、検証と書いています。これはテストで頻出するパターンであり、TDD では検証→実行→準備の順に実装していきます。検証を一番最初に書くことでテストのゴールを明確にするためです。

今回はシンプルな関数なので準備の記述はありませんが、準備では引数に渡す値を用意作成したり、クラスメソッドをテストするのであればクラスの初期化することが一般的です。

ではレッドのまま先に進みましょう。以下のようにコードを書き換えてテストを実行します。

```
test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  const actual = fizzBuzz(1);
  // 検証（Assertion）
  expect(actual).toBe('1');
});
```

するとエラーの内容が`ReferenceError: fizzBuzz is not defined`（fizzBuzzが未定義）に変わりました。fizzBuzz 関数を作成していないから当然なのです。ただ、このエラーを読むと次に何をすればいいか教えてくれていることがわかります。

そこでエラーメッセージに従い、`index.js`で fizzBuzz 関数を作成してテストから呼び出します。

```
// index.test.js
const fizzBuzz = require('./index');

test("1を渡すと文字列'1'を返す", () => {
  // 準備（Arrange）
  // 実行（Act）
  const actual = fizzBuzz(1);
  // 検証（Assertion）
  expect(actual).toBe('1');
});
```

```
// index.js
function fizzBuzz(num) {
  return null;
}

module.exports = fizzBuzz;
```

テストを実行します。`Object.is equality. Expected: "1". Received: null.`（値が一致しない。文字列1を期待しているが null を受け取った）というエラーが表示されました。エラーメッセージが変わったため、fizzBuzz 関数を参照できていることがわかりました。

なお、今回は実装するのは fizzBuzz というシンプルな関数であるためそれほど意識することはないですが、より複雑な関数やメソッドをテストする場合、テスト対象を実装する前にテストで使うことで利用者が理解しやすい命名や引数の設計が可能になります。

### グリーン
次に、最短でこのテストをグリーンにするように fizzBuzz 関数を実装します。

```
function fizzBuzz(num) {
  return '1';
}
```

`$ npm run test`を実行するとテストが通りました（図3）。本当にそれでいいのかと疑問を持つ方もおられるでしょう。しかし、これは「仮実装」と呼ばれるTDDのテクニックなのです。

最短でテストを通すことで、実装者は安心が得られるだけでなくテストコードが間違っていないことも確認できます（実際、著者は本記事の執筆中に`expect(1)`と文字列ではなく数値を期待するテストコードを書いていたため、すぐに通るはずだった仮実装のテストが落ちることによってテスト側にバグが盛り込まれていることに気付きました）。

### リファクタリング
テストがグリーンになったのでリファクタリングを行います。コメントを消して、fizzBuzzの返り値を変数に格納するのをやめましょう。すると index.test.js は以下のようになります。

```
const fizzBuzz = require('./index');

test("1を渡すと文字列'1'を返す", () => {
  expect(fizzBuzz(1)).toBe('1');
});
```

テストを実行してもグリーンのままです。リファクタリングが安全に完了しました。これ以上やることがなくなったので1サイクル目は終わりです。

- [ ] 数を文字列に変換する
  - [x] 1を渡すと文字列"1"を返す → 仮実装
  - [ ] 2を渡すと文字列"2"を返す

## 2を渡すと文字列"2"を返す
### レッド
次にTODOリストから「2を渡すと文字列"2"を返す」というタスクを選んで進めていきましょう。index.test.js に落ちるテストを追加します。

```
test("2を渡すと文字列'2'を返す", () => {
  expect(fizzBuzz(2)).toBe('2');
});
```

`$ npm run test`でテストを実行します。今度は`Object.is equality. Expected: "2".Received: "1"`というエラーが出ました。テストが落ちてレッドになったので、fizzBuzz 関数の実装を進めていきます。

### グリーン
グリーンのステップでは最短でテストが通るように実装します。

```
function fizzBuzz(num) {
  if (num === 2) {
    return '2';
  }
  return '1';
}
```

テストを実行すると問題なくPASSしました。

### リファクタリング
さて、リファクタリングのステップです。テストを見ると数値1、数値2を渡すテストがあります。この処理を一般化してみましょう。

TDD では、処理を一般化する方法がはっきりわからないときに、具体的な値を渡すテストを2つ作成して実装を探るテクニックを「三角測量」と呼びます。

この時点では数値を文字列に変換すれば処理を一般化できます。そこで JavaScript で数値を文字列に変換する`toString()`を活用しましょう。

```
function fizzBuzz(num) {
  return num.toString();
}
```

テストを実行してもパスしたままなのでリファクタリングが完了しました。TODOリストのタスクに完了の印をつけて次に進みましょう。

- [x] 数を文字列に変換する
  - [x] 1を渡すと文字列"1"を返す → 仮実装
  - [x] 2を渡すと文字列"2"を返す → 三角測量

# 3の倍数を渡すと「Fizz」を返す
## 3を渡すと文字列「Fizz」を返す
次にTODOリストから「3を渡すと文字列『Fizz』を返す」というタスクを選択します。

### レッド
まずはテストを追加します。

```
test("3を渡すと文字列'Fizz'を返す", () => {
  expect(fizzBuzz(3)).toBe('Fizz');
});
```

テストを実行すると`Object.is equality. Expected: "Fizz".Received: "3"`と表示されました。テストが失敗したので実装に進みます。

### グリーン
繰り返しになりますがここでは最短でテストが通る実装します。再び仮実装のテクニックを使い、テストをグリーンにしてリファクタリングに進みましょう。

```
function fizzBuzz(num) {
  if (num === 3) {
    return 'Fizz';
  }
  return num.toString();
}
```

### リファクタリング
テストが通ったのでリファクタリングが可能かチェックします。現在の index.test.js は以下の通りです。

```
test("1を渡すと文字列'1'を返す", () => {
  expect(fizzBuzz(1)).toBe('1');
});

test("2を渡すと文字列'2'を返す", () => {
  expect(fizzBuzz(2)).toBe('2');
});

test("3を渡すと文字列'Fizz'を返す", () => {
  expect(fizzBuzz(3)).toBe('Fizz');
});
```

最初の2つのテストと最後のテストはタイプが異なります。このため、TODOリストの構造とテストの構造を合わせるために Jest の describe 関数を使ってテストコードを階層化します。

（櫛引コメント: テストの語彙を describe/it/expect に合わせるために test ではなく it の方がいいかなと思ったのですが、今回は it より直接的な test の方がわかりやすいかなと思い、あえて test にしています。ただ、この点に関してテストの語彙の統一のために it の方が良いか伺いたいです）

```
describe('数を文字列に変換する', () => {
  test("1を渡すと文字列'1'を返す", () => {
    expect(fizzBuzz(1)).toBe('1');
  });

  test("2を渡すと文字列'2'を返す", () => {
    expect(fizzBuzz(2)).toBe('2');
  });
});

describe('3の倍数を渡すと「Fizz」を返す', () => {
  test("3を渡すと文字列'Fizz'を返す", () => {
    expect(fizzBuzz(3)).toBe('Fizz');
  });
});
```

テストを実行すると、結果にTODOリストの階層が反映されていいることがわかります（図4は変更前, 図5は変更後）。

また、数値が3の倍数か判定する方法は明確なので条件判定の処理を書き換えます。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  }
  return num.toString();
}
```

テストを実行するとグリーンのままです。リファクタリングが完了したので、タスクにチェックをつけて次に進みます。

- [x] 3の倍数を渡すと「Fizz」を返す
  - [x] 3を渡すと文字列「Fizz」を返す -> 仮実装 -> 実装

# 5の倍数を渡すと「Buzz」を返す
##  5を渡すと文字列「Buzz」を返す
次に「5を渡すと文字列『Buzz』を返す」というタスクに取り組みます。

### レッド
また落ちるテストを追加します。そろそろレッド、グリーン、リファクタリングのリズムに慣れてきた頃でしょうか。

```
describe('5の倍数を渡すと「Buzz」を返す', () => {
  test("5を渡すと文字列'Buzz'を返す", () => {
    expect(fizzBuzz(5)).toBe('Buzz');
  });
});
```

テストを実行するとちゃんとレッドになりました。

### グリーン
今回のタスクは先ほどのタスクと似ており実装方針が明確です。このため、今回は仮実装をせずにいきなり実装をしましょう。TDDではこの実装方法に「明白な実装」と名前をつけています。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  }
  if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンになるため、次に進みます。

### リファクタリング
今回のリファクタリングでは2つの if 文を if~else 文に変更します。

```
function fizzBuzz(num) {
  if (num % 3 === 0) {
    return 'Fizz';
  } else if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンのままです。TODOリストにチェックをつけて次に進みます。

- [x] 5の倍数を渡すと「Buzz」を返す
  - [x] 5を渡すと文字列「Buzz」を返す → 明白な実装

# 15の倍数を渡すと「FizzBuzz」を返す
##  15を渡すと文字列「FizzBuzz」を返す
最後に「15を渡すと文字列『FizzBuzz』を返す」というタスクを実装していきます。

### レッド
落ちるテストを追加します。

```
describe('15の倍数を渡すと「FizzBuzz」を返す', () => {
  test('15を渡すと文字列「FizzBuzz」を返す', () => {
    expect(fizzBuzz(15)).toBe('FizzBuzz');
  });
});
```

テストを実行すると`Object.is equality. Expected: "FizzBuzz".Received: "Fizz".`というエラーが表示されましたので次に進みます。

### グリーン
今回もこれまでと同様の条件判定を使って仕様を実現できるため、仮実装を飛ばして明白な実装をします。

```
function fizzBuzz(num) {
  if (num % 3 === 0 && num % 5 === 0) {
    return 'FizzBuzz';
  } else if (num % 3 === 0) {
    return 'Fizz';
  } else if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンになりました。

### リファクタリング
最後のリファクタリングを行います。リファクタリングの基本は重複の除去でした。今回、実装コードでは3と5の倍数の判定が重複しています。まずは3の倍数の判定を変数に切り出しましょう。

```
function fizzBuzz(num) {
  const canDivideByThree = num % 3 === 0;

  if (canDivideByThree && num % 5 === 0) {
    return 'FizzBuzz';
  } else if (canDivideByThree) {
    return 'Fizz';
  } else if (num % 5 === 0) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行するとグリーンのままです。次に5の倍数の判定処理を変数に切り出します。

```
function fizzBuzz(num) {
  const canDivideByThree = num % 3 === 0;
  const canDivideByFive = num % 5 === 0;

  if (canDivideByThree && canDivideByFive) {
    return 'FizzBuzz';
  } else if (canDivideByThree) {
    return 'Fizz';
  } else if (canDivideByThree) {
    return 'Buzz';
  }
  return num.toString();
}
```

テストを実行してみます。すると「5を渡すと文字列'Buzz'を返す」というテストが落ちてしまいました（図6）。`Object.is equality. Expected: "Buzz". Received: "5"`というエラーメッセージを読むと5を渡したとき Buzz ではなく文字列5を返していることがわかります。

リファクタリングの際にテストが落ちてしまうことは珍しいことではありません。そんな時は一度リファクタリングを止めてエラーの原因を探します。実装コードを見ると Buzz を返してほしい if 文の条件で使用している変数が3の倍数判定の canDivideByThree になっています。変数を修正して再度テストを実行します。

```
function fizzBuzz(num) {
  const canDivideByThree = num % 3 === 0;
  const canDivideByFive = num % 5 === 0;

  if (canDivideByThree && canDivideByFive) {
    return 'FizzBuzz';
  } else if (canDivideByThree) {
    return 'Fizz';
  } else if (canDivideByFive) {
    return 'Buzz';
  }
  return num.toString();
}
```

今度はテストがグリーンになり、リファクタリングが完了しました。

- [x] 15の倍数を渡すと「FizzBuzz」を返す
  - [x] 15を渡すと文字列「FizzBuzz」を返す → 明白な実装

index.test.js は以下のようになっています。

```
const fizzBuzz = require('./index');

describe('数を文字列に変換する', () => {
  test("1を渡すと文字列'1'を返す", () => {
    expect(fizzBuzz(1)).toBe('1');
  });

  test("2を渡すと文字列'2'を返す", () => {
    expect(fizzBuzz(2)).toBe('2');
  });
});

describe('3の倍数を渡すと「Fizz」を返す', () => {
  test("3を渡すと文字列'Fizz'を返す", () => {
    expect(fizzBuzz(3)).toBe('Fizz');
  });
});

describe('5の倍数を渡すと「Buzz」を返す', () => {
  test("5を渡すと文字列'Buzz'を返す", () => {
    expect(fizzBuzz(5)).toBe('Buzz');
  });
});

describe('15の倍数を渡すと「FizzBuzz」を返す', () => {
  test('15を渡すと文字列「FizzBuzz」を返す', () => {
    expect(fizzBuzz(15)).toBe('FizzBuzz');
  });
});
```

これで TDD で fizzBuzz 関数を実装できました。

## 意図が不明瞭で重複したテストを削除する
これで一通り完成したものの、実際の現場では TDD で開発を進めるとテストケースが増加していきます。いくら実行時間の短いユニットテストといえども、数が増加すれば実行時間も同時に増えていきます。テストケースが増えて CI の実行時間が長引いた場合、テストの実行を並列化したり、コードに変更がない場合にテストをスキップするといったテクニックでテストの実行時間を短縮することができます。

しかし、そもそも不要なテストを削除することも1つの手段です。fizzBuzz 関数の場合、「2を渡すと文字列'2'を返す」というテストケースは三角測量のために作成したテストです。実装を進める過程で一般化が完了しているため、「1を渡すと文字列'1'を返す」というテストと役割が重複しています。

後からプロジェクトに参加した他のエンジニアが「このテストは一見不要に見えるが、残っているのは何らかの意図があるはずだから消さないでおこう」と考えると、そのテストは永遠に残ったままです。このため「2を渡すと文字列'2'を返す」というテストは削除しても構いません。これでテストのメンテナンスコストを少し減らせました。

# TDD がもたらす効果
## TDDの目的はコードに対する自信
TDD で fizzbuzz 関数を実装することで、実装にバグを含んでいないという自信を持つことができたと思います。実装方法がわからない五里霧中の未知の世界から、テストを使って一歩ずつ既知の世界へ進んでいく。エンジニアはソフトウェアの動作を深く把握しているため、リリースに不安がなくなります。これこそが TDD がエンジニアにもたらす最大の効果です。

## TDD はテスト技法ではない
ただし、TDD で実装しているからと言ってソフトウェアにバグが全く発生しないわけではありません。実際、TDD の考案者である Kent Beck も以下のように述べています。

「皮肉なことに、TDDはテスト技法ではない。TDDは分析技法であり、設計技法であり、実際には開発のすべてのアクティビティを構造化する技法なのだ。」（注:『テスト駆動開発』p.278）

TDD は主にユニットテストを記述し、クラスや関数を作る前に使うことで自然にテストしやすい設計、実装をする手法です。 注意すべきは、TDDだからといってバグが全てなくなるわけではないということです。エンジニアが想定したテストケースを通った実装であっても、ユーザーがエンジニアの思わぬソフトウェアの使い方をしたり、探索的テストを通してバグが見つかる可能性はゼロではありません。

例えば、先ほど実装した fizzBuzz 関数の引数に文字列や null など数値以外の値を渡せばエラーになります。このようにもし実装に不安があるなら、さらにテストケースを足して不安を解消しましょう。

# 現場で TDD を実践するために
現行のプロジェクトで TDD を実践するためのコツを3つご紹介します。

## 周りを巻き込んでテストを実行する環境を構築する
1つ目は、もし現行のプロジェクトにテストを各環境がないのであれば、テストを書く環境を作るために周りの人を巻き込むことです。テストを書くに当たり、プロジェクトで採用している使用言語に応じたテスティングフレームワークを選定したり、CI 環境の構築が先決になるからです。チームメンバーを巻き込んで、ときにテックリードやインフラチームや基盤チームなど周囲の助けを借りながら環境の構築をすることが第一歩です。

## バグが発生した時にテストを書いてバグを再現する
2つ目は、バグが発生した際にそのバグを再現するテストを記述することです。そして、テストが通るように実装を書き換えれば同様バグは二度と起こらなくなる上に、今後手動で動作を確認する必要もなくなります。

これについて、私が現場で経験したエピソードをご紹介します。フロントエンドのアプリケーションを TDD で実装したときに画面の表示に関するバグが1件発生しました。それは検索ワードを検索結果でハイライトする処理で、検索ワードに複数の単語を指定したときに2つ目以降の単語が検索結果でハイライトされていないという現象でした。その際、まずバグを再現するテストケースを追加して、ハイライトのロジックを書き換え、テストが通ることを確認してリリースしました。その後、二度と同様のバグは起きませんでした。

## テストのない既存機能の改修前にテストを書く
3つ目は、既存機能の改修のタイミングでテストを書くことです。新規機能開発であれば最初からテストを書けばよいですが、テストのない既存機能に手を加える必要がある場合、まずは既存の処理のテストを記述してみましょう。そうすることで、安心してリファクタリングが可能になります。 そして、リファクタリングをした後に既存の機能を改修してみましょう。

実際の現場では、工数管理をするプロジェクトマネージャーに対して機能開発時にリファクタリングの工数も見積もりに含めるなど調整が必要になります。しかし、リファクタリングをした後は簡単に機能が追加でき、自分が書くコードに自信を持てるはずです。

何よりテストがあることでリリース毎にユーザーにバグを届ける割合が減り、バグ発生のアラートが届く回数が減り、既存機能のバグ修正のパッチを書くことに追われていた時間が減ります。結果、ユーザーに価値を届けることに集中できるようになります。

# おわりに
TDDでfizzBuzzを実装してみました。普通に実装するのとは異なり、自分のコードに対する自信を持つことができたのではないでしょうか。今回は JavaScript を使いましたが、TypeScript のような静的型付け言語を使うとコンパイラがエラーを出してくれます。第2章のテスティングトロフィーにあるように、これも設計を駆動するテストの1つです。

今回実装したコードは GitHub で公開しています(注釈1)。余力があれば fizzBuzz 関数を使ったチャレンジとして、「数値以外の値を渡したとき、例外を発生させる」というテストを追加したり、リファクタリングとして倍数の判定を canDivideBy という関数に切り出してみてください。

さらに TDD に対する理解を深めたい方は、私が本記事を執筆するにあたり参考にした @t_wada さんの TDD のライブコーディング動画もぜひご覧ください(注釈2)。実際に他の人がどのように実践しているかを知りたい、体験したい場合は勉強会（注釈:3）に参加するのも1つの手です。他にも TDD で別の課題に挑戦するのであれば、Bob Martin 氏が考案したボウリングゲームを実装してみるのもオススメです。（注釈 4）

(注釈1): https://github.com/KushibikiMashu/tdd-js-fizzbuzz
(注釈2): https://youtu.be/Q-FJ3XmFlT8
(注釈3): TDD Boot Camp https://tddbc.connpass.com/ や TDDワイワイ会 https://tddyyx.connpass.com/ などの勉強会があります。
(注釈4): https://oblac.rs/tdd-kuglanje-i-teca-bob/Bowling_Game_Kata.pdf

TDD は実装がないのに先にテストを記述したり、テストケースで最初に検証を書いたり、エラーが起きない限り実装を進めないなどエンジニアの直感に反するテクニックです。しかし、TDD は個人的な技法であるため思い立ったら誰でもすぐに始められます。

TDD の考案者である Kent Beck 氏はこのように述べています。「私は偉大なプログラマではない。偉大な習慣を身につけたプログラマだ。」ぜひ TDD という直感に反する偉大な習慣を身につけて、自信を持ってソフトウェアをリリースしていきましょう。この記事がみなさんの日々の開発のお役に立てれば幸いです。
