---
title: "弁護士ドットコムライブラリーのフロントエンドのアーキテクチャ（Next.js + TypeScript）"
date: "2020-12-02T00:14:09.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/bengo4com-library-frontend"
category: "React"
tags:
    - "Next.js"
    - "React"
    - "TypeScript"
description: ""
socialImage: "/media/2020/12/02/2020_12_02__0.png"
---

## 弁護士ドットコムライブラリーのフロントエンドのアーキテクチャを紹介します
この記事は、[弁護士ドットコム Advent Calendar 2020](https://qiita.com/advent-calendar/2020/bengo4com)、2日目の記事です。

私は[弁護士ドットコムライブラリー](https://library.bengo4.com/)という法律書籍をネットで読めるの弁護士向けのサブスクリプションサービスを開発しています。フロントエンドの採用技術はNext.js + TypeScriptで、要件定義から設計、実装は私が担当しました。

この記事では、2020年5月にリリースしてから半年間、Next.jsでサービスを運用した知見の中から、アーキテクチャ（主にディレクトリ構成）についてご紹介します。Storeの構成については今回は触れません。

なお、上記のサービスの特徴は以下の通りです。

- 画面数は10画面ほどの中規模アプリケーション（OOUIの考え方を取り入れたら画面数が減りました）
- 基本的にバックエンドから渡されるデータを整形・表示することがメイン
- バックエンドは認証、書籍検索、課金（Stripe）に分かれているマイクロサービス
- ECS上でNodeコンテナとして運用しているため、VercelやNetlifyは利用していない
- デザイナーさんがHTML+CSSを記述してくれるので、Atomic Designは採用していない

現在、弁護士ドットコムに登録している弁護士の方、または弁護士事務所の事務所単位の方のみ登録可能です。ただ、書籍の検索は誰でも可能なので、動作させてみたい方は[トップページ](https://library.bengo4.com/)から検索ワードを入力してみてください。

また、技術スタックは以下の通りです。

```
- フレームワーク: Next.js（React） + TypeScript
- 状態管理: useContext
- データフェッチ: fetch（Next.js組み込み）、 SWR
- CSS: CSS Modules（SCSS）
- テストフレームワーク: Jest + @testing-library/react-hooks
- CDN: Akamai
- CI: GitLab CI
- インフラ: ECS、ECR、RDS（MySQL）
- 監視: Datadog
- その他: ESLint・Stylelint・Storybook、Renovate、Docker Compose、Stripe
```

普段はDiscordを使い、毎日ペアプログラミングで開発しています。

## レイヤードアーキテクチャを採用
結論から記述すると、フロントエンドでレイヤードアーキテクチャを採用しました。

![レイヤードアーキテクチャ](/media/2020/12/02/2020_12_02__1.png)

（図はマーティン・ファウラーのブログ記事[「PresentationDomainDataLayering」](https://martinfowler.com/bliki/PresentationDomainDataLayering.html)より）

レイヤードアーキテクチャを採用し、各レイヤーがクリーンになるように設計しています。フロントエンドで[ボブおじさんのクリーンアーキテクチャ](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)を適用する試みが見られますが、クリーンアーキテクチャはWebすら外部のI/Oであると定義しており、MVC2ではなくデスクトップアプリケーションのMVCを想定していると考えられます。

弁護士ドットコムライブラリーはWebアプリケーションであるため、クリーンアーキテクチャを適用しましたとは言わないものの、クリーンアーキテクチャのエッセンスを抽出した「クリーンなアーキテクチャ」を目指して設計しました。

クリーンなアーキテクチャの特徴は、以下のようなものです。

- レイヤーごとの責務が明確であること
- モジュールの依存の方向が制御できていること
- モジュールがテスタブルであること（本記事執筆時点で、Unit Testのテストカバレッジは85%です）
- 外部のものはアダプターとして使い、アプリケーション内に依存をばら撒かないこと

これらの特徴を備えたアプリケーションは、メンテナンス性に優れており、仕様の追加や変更に強く、コードの処理を追いやすくなります。また、テストを記述しているためアプリケーションのバグ混入率を減少させることができ、安心・安全にデプロイできます。つまり、質とスピードを両立できるアーキテクチャなのです。

## ディレクトリ構成
次にディレクトリ構成をご紹介します。

```
├── pages                    # next.jsのページコンポーネント。各tsxのファイル名がURLのpathに対応している。
├── public                   # 静的ファイルを置く場所。faviconとか、サイトのロゴなど
│   └── images               # サイト内で使用する画像
└──src
    ├── assets              # Componentsで利用する共通のSCSS
    ├── components          # ReactのFunction Components
    ├── hooks               # コンポーネント間で共通のReact Hooksを置いている
    ├── interactors         # Network層。HTTPを介して外部と通信するクラスを置いている
    ├── lib                 # Adapter層。moment.jsやGoogle Analyticsのライブラリなどを利用する
    └── type                # アプリケーション内で共通の型を置いている
        ├── API             # RESTful APIのエンドポイントから返却されるJSONの型
        └── domain          # アプリケーション内で利用する型
```

Next.jsを採用しているため、ルートディレクトリにあるpagesディレクトリのファイルがルーティングに対応しています。ファイルシステムに基づいたルーティングは、素のHTMLをサーバーで配信するのと同じですね。

components内には、React Componentを記述しています。この中は、export用のindex.tsx、FooComponents.tsx、コンポーネント内で利用するSCSS（styles.module.scss）、Storybook用のコンポーネント（index.stories.tsx）、プレゼンテーションロジックを記述するpresenter（後述）を配置しています。

また、interactorsというディレクトリはあまり見かけないと思います。役割はfetcherとmapperです。つまり、APIのレスポンスデータであるJSONをJavaScriptのオブジェクトに変換し、TypeScriptでドメインの型にマッピングするための処理を記述しています。このレイヤーにより、APIの変更による影響を最小限に抑えることができます。こちらは次の章で説明します。

なお、ユーザーのリクエストからレスポンスまで、データフローは以下のような流れです。

![データフロー](/media/2020/12/02/2020_12_02__2.png)

## InteractorとMapper（データアクセス層）
### Interactorの役割
Interactorはバックエンドからデータを取得するレイヤーです。`interactors`ディレクトリの中身は下記です。

```
interactors
├── BaseInteractor.ts
├── Books: 書籍データを持つElastic Searchサーバー
│   ├── Book
│   │   ├── BookInteractor.ts
│   │   └── BookMapper.ts
│   └── Search
│       ├── SearchInteractor.ts
│       └── SearchMapper.ts
├── Payment: Stripeサーバー（決済）
│   ├── Card
│   │   └── CardInteractor.ts
│   ├── Customer
│   │   └── CustomerInteractor.ts
│   └── Subscription
│       ├── SubscriptionInteractor.ts
│       └── SubscriptionMapper.ts
└── Session: Sessionサーバー（ユーザー認証情報）
    ├── SessionInteractor.ts
    └── SessionMapper.ts
```

- BaseInteractorは、fetchをラップした、get, post, put, deleteメソッドを備えたクラス。
- Book、Payment、Sessionの3種類のInteractorは、それぞれ書籍の検索、課金、ログインセッションサーバーの各エンドポイントに対応している
- この３種類のInteractorクラスにBaseInteractorを注入し、HTTPメソッドに応じた通信をする
  - 例えば、BookInteractorのfindByIdなら、書籍のIDをBaseInteractorのgetメソッドに渡して、書籍サーバーからデータを取得する

```tsx:title=BookInteractor.tsx
export default class BookInteractor {
  // ClientInterfaceはget/post/put/deleteメソッドを持つインターフェースです
  private readonly interactor: ClientInterface

  constructor() {
    // BaseInteractorを注入
    this.interactor = BaseInteractor.createBookInteractor()
  }

  findById = async (id?: string): Promise<Book | null> => {
    if (typeof id === 'undefined') {
      return null
    }

    // IDに応じた書籍データを取得する
    const res = await this.interactor.get(`${BOOK_BIBLIOGRAPHIES_PATH}/${id}`)
    try {
      const body: BookBody = await res.json()
      // 次で解説しています
      return BookMapper.bibliographyBodyToBook(body)
    } catch (e) {
      // 例外をnullで表現していますが、アンチパターンだと思うため要リファクタリングです😅
      return null
    }
  }
}
```

エンドポイントごとにInteractor（fetcher）を用意しています。これにより、エンドポイントが増えればInteractorを追加すればよく（Open Closed Principle）、「書籍を全件取得する」という仕様が追加された場合、`BookInteractor`に`findAll`メソッドを記述するだけでOKです（Single Responsibility Principle）。クエリストリングは`interactor.get`の第二引数に渡します。

### Mapperの特徴と役割
MapperはInteractorのメソッドと1対1対応しています。つまり、Mapperはエンドポイントから返されるJSONをドメインの型にマッピングするためのクラスです。

```tsx:title=BookMapper.tsx
export default class BookMapper {
  // BookBodyはレスポンスの型、Bookがアプリケーション内で利用する型です
  static bibliographyBodyToBook = (result: BookBody): Book => ({
    id: result.content_id,
    title: result.title.main,
    subTitle: result.title.sub,
    authors: result.authors || [],
    publisher: result.publisher,
    publishedAt: result.release_date,
    tableOfContents: result.toc,
    thumbnailUrl: result.thumbnail_url,
    abstract: result.abstract,
    url: result.url,
  })
}
```

Mapperの目的は、フロントのアプリケーションをバックエンドが返却する値に依存させないためです。Mapperというレイヤーを設けておくことで、バックエンドに変更が加わっても、このMapperを変更するだけで済みます。例えばJSONのキー名が変わってもMapperを書き換えれば済むため、アプリケーション内部の変更の影響を最小限に留められます。

Reactとの接続では、useEffect内でInteractorを呼び出すことでレスポンスデータを扱います。

```tsx
type Props = { id?: string }

const Book: React.FC<Props> = (props) => {
  const [book, setBook] = useState({})

  useEffect(() => {
    async(() => {
      setBook(await new BookInteractor().findById(props.id))
    })()
  }, [])

  if (book === null) {
    return <Error message={"書籍取得に失敗しました"} />
  }

  return <h1>title: {book.title}</div>
}
```

このInteractorはSWRでも活用できます。

```tsx
type Props = { id?: string }

const Book: React.FC<Props> = (props) => {
  const { data: book, error } = useSWR<Book>(
    `${BOOK_BIBLIOGRAPHIES_PATH}/${props.id}`,
     () => new BookInteractor().findById(props.id)
   )

  if (!book) {
    return <Loading />
  }

  if (error) {
    return <Error message={"書籍取得に失敗しました"} />
  }

  return <h1>title: {book.title}</div>
}
```

## ReactコンポーネントとPresenter層（プレゼンテーション層）
バックエンドからのデータ表示がメインのアプリケーションであるため、Interactorから渡された値を表示するためのPresenter層を用意します。バックエンドに例えるとMVVMのViewModel層に相当します。

その前に、Reactコンポーネントの書き方をご紹介します。

### クリーンなReactコンポーネントの書き方
Reactコンポーネントは、@takepepeさんの[「経年劣化に耐える ReactComponent の書き方」](https://qiita.com/Takepepe/items/41e3e7a2f612d7eb094a)を採用し、アレンジしています。

この記事の意義は、Vue.jsのSFCの書き方をReactに導入したことです。これにより、Viewとロジックを分離できます。

なお、弁護士ドットコムライブラリーではチームのデザイナーさんがHTMLとCSSを記述してくれるため、CSS Modulesを採用しています。

例えば、Greetingコンポーネントがあると仮定すると、src/components/greeting以下は下記のような構成です。

```
src/components/greeting
├── __tests__
│    ├─ useGreeting.test.ts
│    └─ presenter.test.ts
├── index.ts
├── index.stories.ts
├── Greeting.tsx
├── presenter.ts
├── useGreeting.ts
└── style.module.css
```

今回は、hooks、テストの記述は省略します。なお、ドラッグ&ドロップなどの複雑なUIの操作は存在しないため、`@testing-library/react`によるコンポーネントテストは導入していません。CypressによるE2Eテストは導入したいと思っていますが、現在は`Jest`と`@testing-library/react-hooks`によるUnit Testのみです。

```tsx:title=Greeting.tsx
import React, { memo } from 'react'
import css from './style.module.scss'

type ContainerProps = {
  target?: string
}

type Props = Required<ContainerProps>

// デザイナーさんはComponentのJSXを記述すれば良い
// StorybookではComponentのみをimportする
export const Component: React.FC<Props> = (props) => (
  <h1 className={css['greeting']}>
    Welcome to, <span className={css['greeting__target']}>{props.target}</span>
  </h1>
)

// フロントエンドエンジニアが書く
// propsをComponentで表示するデータ形式に書き換える
const Container: React.FC<ContainerProps> = (props) => {
  const target = props.target || 'world'

  return <Component target={target} />
}

Container.displayName = 'Greeting'

// memo化はComponent、ContainerのどちらでもOK
export default memo(Container)
```

コンポーネントのmemo化については、ContainerでもComponentでもどちらでも適切な方をReact.memoでラップしましょう。

また、Storybookのコンポーネントは以下のように記述しています。Storybookはプレゼンテーションであるため、Componentをimportします。Containerに記述するlocal stateやデータの変換処理は不要です。Storybook上でコンポーネントのstateを操作せずとも、Container（ViewModel）の処理の結果、Componentに渡されるデータを複数種類用意すれば十分です。

以下は、Storybook v6 + TypeScriptの記述方法です。

```tsx:title=index.stories.tsx
import { Meta, Story } from '@storybook/react'
import { Component as Greeting, Props } from './Greeting'

export default {
  title: 'components/Greeting',
  component: Greeting,
  argTypes: {
    target: { control: 'text' },
  },
} as Meta<Props>

const Template: Story<Props> = (args) => <Greeting {...args} />

export const World = Template.bind({})
World.args = {
  target: 'World',
}

export const Next = Template.bind({})
Next.args = {
  target: 'Next.js',
}
```

### Presenterの役割
さて、Presenterについて紹介します。presenterは、Container内でのロジックをテスト可能にするためのクラスや関数を置くファイルです。presenterに渡すデータのロジックに応じてクラスと関数を使い分けます。クラスであれば、コンストラクタでデータ（大抵は大きめのオブジェクト）を渡します。マルチパラダイムというわけではないですが、どちらの強さをも発揮できるように適切に組み合わせています。

`presenter.ts`は、コンポーネントに1対1に対応するロジックを記述します。「コンポーネントに閉じるロジックなら、Containerに直接関数を書いてもいいのでは？」と言う意見もありました。しかし、クリーンなアーキテクチャの観点からロジックをコンポーネントから切り出しています。理由は以下の通りです。

- Container内のロジックをテスト可能にする
- コンポーネント内にはPresentational Componentとロジックを記述するContainerしか配置しない
  - 見通しが悪くなるため、ちょっとしたfunctionや子コンポーネントは同一ファイルに記述しない
  - Container ComponentからPresenterを呼び出す
- Reactコンポーネントのファイルは1ファイル100行以下にしておきたい

実際のPresenterは以下のように記述しています。

#### 関数のPresenterの例
ページごとにヘッダーにある検索欄の表示/非表示を切り替えるロジックです。なお、各ページのパスは定数に切り出しています。

```ts:title=presenter.ts
const canShowSearchInput = (
    pathname: string,
    keyword: string | undefined,
    hitCount: number | null
): boolean => {
  switch (pathname) {
    case SITE_SEARCH_PATH:
      // 検索結果が0件の場合は表示しない
      if (hitCount === 0) {
        return false
      }
      // キーワードが存在しないときは表示しない
      return !!keyword
    case SITE_BOOKS_ID_PATH:
      // 書籍の個別ページなら、必ず表示する
      return true
    default:
      return false
  }
}

export default canShowSearchInput
```

このようなロジックは要件が複雑になると記述量が増えるためContainerコンポーネントの中に書きたくないし、stateを使ったロジックでもないので、あえてコンポーネント内に書く必要もありません。表示、非表示なのでbooleanさえあればよく、`presenter.ts`に切り出すのが適切と言えるでしょう。

あとはContainerで処理を呼び出すだけです。

```tsx:title=Header.tsx
import Logo from '~/src/components/logo'
import Presenter from './presenter'

type ContainerProps = {
  pathname: string
  keyword?: string
  hitCount: number | null
}

type Props = {
  canShowSearchInput: boolean
}

export const Component: React.FC<Props> = (props) => (
  <nav>
    <Logo />
    {props.canShowSearchInput && <SearchInput />}
  </nav>
)

const Container: React.FC<ContainerProps> = (props) => {
  const canShowSearchInput = Presenter.canShowSearchInput(
    props.pathname,
    props.keyword,
    props.hitCount,
  )

  return <Component canShowSearchInput={canShowSearchInput} />
}
```

#### クラスによるPresenterの例

// TODO
（検索条件の詳細コンポーネント）

ポイントは、writeの要件がほとんどないアプリケーションであるため、Storeのスキーマに合わせるようにデータを変換する処理が不要である点です。Storeをフル活用する場合、ロジックはさらに増えるでしょう。

Presenterのテストを記述することにより、ユーザーに意図しない形でデータが表示されているかもしれないという不安がなくなります。

## 型の依存の話
src/typesの

## マーティン・ファウラーのPresentationDomainDataLayeringとの対応
最後に、冒頭で紹介したファウラー氏のPresentation、Service, Domain Objects、Data Mapper、Data Accessと各レイヤーの対応をチェックします。

![レイヤードアーキテクチャ](2)

### Presentation
PresentationはReact ComponentのContainerのロジックとPresenterに対応する。

### Service, Domain Objects
基本的にこの層に対応するレイヤーはない。APIからjsonで取得したデータを表示させるだけであるので、Entitiy同士が相互作用する場面や、Storeへ値を格納する場面がないため。

### Data Mapper
APIから取得したJSONをアプリケーション内で使う型に変換する。具体的には、InteractorのディレクトリにあるMapperが対応する。Interactorの各メソッドとMapperは1対1で対応している。

### Data Access
Data AccessはInteactorに対応している。Inteactorという名前は@tenjuuさんの開発している[業務システム](https://www.bengo4.com/lawyer/gyosys/)のコードを参考にしている。なお、業務システムはNuxt.js + BEAR.Sunday（PHP）で構築されている。


## 半年間運用してみてオススメしたいこと
- PresenterとComponentを分けるのはとても良い
- 何をどこに書くか悩まない
- 現状でも十分良いが、もっと良くなりそう
  - E2E

## これからリファクタリングしていきたい
- コンポーネントをpages/sharedで分ける
- Next.jsのpagesはNext.jsとstoreとの接続層。ReduxのContainer層。

理想系はまだ先。やりたいことはたくさん。フロントエンドの方は現在募集していないです。質問があればtwitterまでぜひ。

また、結局アーキテクチャ、採用技術はアプリケーションの仕様・要件次第です。今回は、write要件の少ないアプリケーションのアーキテクチャ例として一読いただければ幸いです。

そして、この考え方はReactに留まらないと思います。
