---
title: "Redux Toolkitの構成技術を触ってみた（reselect・Immer・Redux Thunk）"
date: "2020-11-19T23:47:08.000Z"
updatedAt: ""
template: "post"
draft: false
slug: "/posts/redux-toolkit-library"
category: "React"
tags:
    - "Redux"
    - "React"
    - "Redux Toolkit"
description: "Redux ToolkitはReduxのエコシステムから選りすぐりの技術を集大成したライブラリだ。単にReduxのボイラープレートを減らすだけのライブラリではない。Redux Toolkitは以下の技術の組み合わせである。この記事では、Redux Toolkitの構成技術に対する所感を紹介している"
socialImage: "/media/2020/11/19/2020_11_19__0.png"
---

## Redux Toolkitとは、Reduxのエコシステムの集大成である
Redux ToolkitはReduxのエコシステムから選りすぐりの技術を集大成したライブラリだ。単にReduxのボイラープレートを減らすだけのライブラリではない。Redux Toolkitは以下の技術の組み合わせである。

以下ではRedux Toolkitの構成要素となるライブラリの基本的な使い方を確認していく。注意して頂きたいのは、**以下の記述はRedux Toolkitでの書き方ではない点だ**（それなら公式ドキュメントをご覧いただくのが一番である）。

大きくて複雑なものに遭遇したときは常にBack to the Basic。基本に立ち返ろう。

### reselect: Storeから値を取得する処理をメモ化する
reselectは関数をメモ化をするライブラリ。1ファイル150行程度の薄いライブラリ。Storeから必要な値を取得するためのロジックを記述する。

他のメモ化の方法と同様に、メモ化した関数に以前と同じ値を渡すとその関数内の処理をスキップしてメモリから計算結果を返してくれる。どんなに重い処理をしている関数でも、実行時間はO(1)になる。

大体以下のような書き方になる。Storeから完了したTodoのみを取得する処理を例とする。

```jsx
import { createSelector } from 'reselect'

const todosSelector = (store: Store) => store.todos
const getDoneTodos = createSelector(todosSelector, (todos)
    => todos.filter(todo => todo.isCompleted)
```

store.todosの値が同じである限り、2度目以降は`todos.filter(todo => todo.isDone)`というfilter処理は再実行されない、と理解している。

つまり`const completedTodos = useSelector(state => state.todo.filter(todo => todo.isCompleted))`と書くと、Reactコンポーネントが再レンダリングされる度にfilterの O(n) の処理 が実行されるが、reselectだとメモ化されているためO(1)であるという認識だ。

処理がfilterのみの場合はtodoが2億個ある場合でやっと恩恵があるかもしれないが、Storeからの値取得のロジックはともすると重くなりがちだ。

Storeの一部の値が変わっていないのに再計算を毎回実行すると処理が重くなる。reselectは、その問題を回避するのに役立つ。

ちなみに「関数が重い」というとき、実行時間が長い場合とロジックが複雑であるという二つの意味がある。前者はreselectで対策できるが、後者は別の解決策が必要だ。

selector内のビジネスロジック、というかグローバルなStoreからフロントで利用する値に変換するドメインロジックが複雑になるという課題に対しては、仕様を調整するか、せめてSelectorのテストをしっかり書いておくのが良い。

なお、プレゼンテーションロジックはselectorの中に書くべきではない。Reactコンポーネントの中に書くべきだ。それはViewModelのロジックをObjectMapperに書くと保守性が破綻することは想像に難くない。

### Immer: オブジェクトの更新をイミュータブルにする
JavaScriptオブジェクトをイミュータブルに扱えるFacebook製のライブラリ。Storeを更新するReducerと組み合わせて使う。Storeのネストが深くなると、ピンポイントで値を更新したくなるからだ。

いちいち`{...store, foo: {...store.foo, bar: 'newValue' }}`などと書いてられない。2階層目でこれなのだから、さらに深くなると先が思いやられる。

Immerを使うと以下のように書ける。

```js
const reducer = (draft: State = initialState, action: Action) => {
  switch (action.type) {
    case 'SOME_ACTION:
      draft.foo.bar = 'newValue'
      return
    // ...
    }
}
```

このReducerを`useImmerReducer`というReact Hooksに渡す。

```js
import { useImmerReducer } from 'use-immer'

const [state, dispatch] = useImmerReducer(reducer, initialState)
```

使い方はuseReducerと変わらない。しかし、注意して欲しいのは、`useImmerReducer`に渡すreducerは返り値を返さない点である。

（draftの中身をconsole.logで確認すると `{ draft: foo: { proxy: {} } } }`のような形式になっていたが、内部処理を追っていないのでよくわからない。）

「reducerは純関数だ」と叩き込まれている身としては、reducerが返り値を返さない点、あたかも変数に（しかも関数の引数に！）値を再代入しているように見える書き方に最初は抵抗があった。

しかし、ピンポイントでStoreの値を更新できるので、一度使ってみるとこれがとても便利なのである。なお、内部では新しくオブジェクトが生成されているようだ。

### Redux Thunk: Reduxで非同期処理を扱う
Redux Thunkは非同期処理を扱うライブラリだ。Reduxを入れるなら必須であるといえる。Thunkを入れない場合はuseEffectの中でactionをdispatchする書き方になる（それも悪くない）。また、React開発者なら経験人数も多いため採用には困らない。

（2年前はReduxで非同期処理を扱うならRedux ThunkかRedux Sagaのどちらかという印象があったが、Saga経験者は採用市場で見かけたことがないので、新規で採用するには覚悟のいる技術だろう）

Redux ToolkitがRedux Thunkを組み込んだことにより、「Reduxで非同期処理ならThunk」というトレンドは今後も続く。

さて、Thunk自体の解説は日本語での記述も豊富なのでそちらを参照してもらうとして、所感を書く程度に留めたい。

なお、Reduxでは「Actionをdispatch → Storeを更新する」のに対して、Redux Thunkは「Async Actionをdispatch → 非同期処理 → Storeを更新する」という理解である。

Redux ThunkはReduxの世界で非同期処理を扱うライブラリである。この点を意識すると、Redux Toolkitの`builder.addCase(asyncThunk.pending)`などの一見奇怪な書き方がボイラープレートを減らしていることを理解できるだろう。

まず確認すべきことは、Reduxは「ReactやVue.jsといったフロントエンドのライブラリから独立した、状態管理のライブラリである」という点だ。

状態管理とは詰まるところ、Storeというグローバルなオブジェクトに保持した値の一群をアプリケーションの状態と見なすことだ。内部のアプリケーションの状態がどのようであれ、表示とは無関係なのだ。

非同期処理の中でも特にバックエンドへのリクエストを考えると、`idle`（リクエストを送る準備ができている状態）、`pending`（返却を待っている状態）、`fulfilled`（値が帰ってきた状態）、`rejected`(値の取得に失敗した状態)の4つに大別できる。

例えば、ボタンをクリックすると新着メッセージを取得するアプリケーションを想像して欲しい。

それぞれの状態をUIに対応させると、idleはボタンをクリックできることがわかる（disabledではない）、pendingはボタンがdisabledになると同時にローダーがぐるぐる回っている、fulfilledはボタンが再度クリックできるようになり、メッセージが表示される、rejectedは赤いトーストが表示されて、失敗の原因をユーザーに伝える。

これらのUIは一つの例である。fulfilledに緑のトーストで表示しても良い。状態は一つである一方、表現方法は多種多様だ。簡単に切り分けると、Reduxは前者、Reactは後者をJavaScriptで扱うライブラリなのである。

さて、状態と表示が分離されていることがわかったところで、接続のことを考えなければならない。非同期処理の状態をStoreに格納し、ReactコンポーネントがStoreの変更を検知して、状態に応じた表現をする。

Redux Thunkでは、非同期処理の状態に応じてStoreの値を変更するActionを、サーバーへのリクエストの数だけ記述しなければならなかった。Redux Toolkitはそのボイラープレートを減らす書き方を用意している。

## 技術選定のポイント
Redux Toolkitに関する技術選定のポイントを簡単に記述する。導入を検討しているチームの参考になれば幸いである。

- Redux ToolkitはReduxのエコシステムの集大成
- 小・中規模のアプリケーションには、学習コストが大きいため不向きかもしれない。が、チームのRedux経験者の数と実力による
- React外の処理の記述が公式ドキュメントに記載されているので、開発者間で記述にブレが少なくなるのはメリット
- useEffectの中のロジックはasync actionに記述することになる
- reselectが組み込まれているのでselectorのメモ化できるものの、プレゼンテーションロジックのメモ化は引き続きuseMemoを推奨
- React QueryやSWRといったデータフェッチをするライブラリと相性はよくない（どちらを使うべきか迷うのであれば、最初から全部Redux Toolkitに寄せた方が無難）

ちなみに、React Suspenseは従来のFetch on Renderをしないようにする技術であるため、Redux Toolkit（Redux Thunk）を使う限り、Suspenseの書き方はできないのではないだろうか、と懸念している。

なお、私は本業でNext.js + SWRで中規模のアプリケーションを開発しており、エンジニアのメンバーは2人だ、という前提を共有したい。Redux Toolkitに対して少し控えめなのはポジショントークであるため、導入はチームの状況と相談するのが良い（情報の吟味は発信者のバックグラウンドを精査することから始まるのだから）。
